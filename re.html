<!doctype html>
<html lang="">	
<head>
	<meta charset="utf-8"/>
	<title>正则表达式 - Lucky Star</title>	

	<meta name="author" content="潇潇" />
	<meta name="copyright" content="潇潇" />
	<meta property="og:site_name" content="Lucky Star" />
	<meta name="twitter:card" content="summary" />
	<meta name="twitter:title" content="正则表达式" />
	<meta name="date" content="2019-08-08 10:20:00+02:00" />
	<meta property="og:type" content="article" />
	<meta property="og:locale" content="zh" />
	<meta property="og:published_time" content="2019-08-08 10:20:00+02:00" />
	<meta property="og:title" content="正则表达式" />
	<meta property="og:url" content="/re.html" />
	<meta property="og:description" content="正则表达式 ​ 正则表达式，又称规则表达式。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 特点： 灵活性、逻辑性和功能性非常强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。 基础语法： 元字符 描述 \ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念 …" />
	<meta name="description" content="正则表达式 ​ 正则表达式，又称规则表达式。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 特点： 灵活性、逻辑性和功能性非常强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。 基础语法： 元字符 描述 \ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念 …" />
	<meta name="HandheldFriendly" content="True" />
	<meta name="MobileOptimized" content="320" />
	<meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0" />
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
	<link rel="icon" href="/favicon.ico" type="image/x-icon" />
	<link href='https://fonts.googleapis.com/css?family=Droid+Sans:700,400|Droid+Sans+Mono' rel='stylesheet' type='text/css' />
	<link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
		
	<!--[if lt IE 9]>
		<script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
</head>
	
<body>		
	<header class="clearfix" role="banner">
		<div class="wrapper">
			<h1 class="huge"><a href="">Lucky Star</a></h1>
		</div>
	</header>
	
<div role="main" class="content clearfix">	
	<article>
		<div class="post wrapper">
			<h1>正则表达式</h1>
			<h1>正则表达式</h1>
<p>​   正则表达式，又称规则表达式<strong>。</strong>正则表达式是对<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6">字符</a>串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。  </p>
<h2>特点：</h2>
<blockquote>
<p>灵活性、逻辑性和功能性非常强；</p>
<p>可以迅速地用极简单的方式达到字符串的复杂控制。</p>
<p>对于刚接触的人来说，比较晦涩难懂。</p>
</blockquote>
<p>由于正则表达式主要<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1">应用对象</a>是文本，因此它在各种<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8">文本编辑器</a>场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。</p>
<h2>基础语法：</h2>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td 1_="1,">匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于</td>
</tr>
<tr>
<td>?</td>
<td 0_1="0,1">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于</td>
</tr>
<tr>
<td>{<em>n</em>}</td>
<td><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td>{<em>n</em>,}</td>
<td><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{<em>n</em>,<em>m</em>}</td>
<td><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（<em>,+,?，{</em>n<em>}，{</em>n<em>,}，{</em>n<em>,</em>m*}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 ['o', 'o', 'o', 'o']</td>
</tr>
<tr>
<td>.点</td>
<td>匹配除“\n”和"\r"之外的任何单个字符。要匹配包括“\n”和"\r"在内的任何字符，请使用像“[\s\S]”的模式。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何可见字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>( )</td>
<td>将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。</td>
</tr>
<tr>
<td>|</td>
<td>将两个匹配条件进行逻辑“或”（or）运算。例如正则表达式(him|her) 匹配"it belongs to him"和"it belongs to her"，但是不能匹配"it belongs to them."。注意：这个元字符不是所有的软件都支持的。</td>
</tr>
</tbody>
</table>
<h2>贪婪非贪婪：</h2>
<p>如果<strong>问号<strong><em>*?</em>*紧跟在任何使用</strong>闭合</strong>（类似<strong><em> +</em>* 这样的操作符）的匹配后面， 它将直接要求正则表达式引擎匹配</strong>尽可能少<strong>的次数，这叫做</strong>非贪婪**</p>
<p><strong>贪婪匹配</strong>：正则表达式引擎将试图“吸收”匹配该模式的<strong>尽可能多</strong>的字符
<strong>非贪婪匹配</strong>：问号要求正则表达式引擎去<strong>“偷懒”</strong>，如果可能，就在当前的正则表达式中尽<strong>可能少</strong>地匹配字符，留下尽可能多的字符给后面的模式</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mystr</span> <span class="o">=</span> <span class="s1">&#39;a*b*c*d*e*f*g&#39;</span><span class="n">ac</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.+?&#39;</span><span class="p">,</span> <span class="n">mystr</span><span class="p">)</span> <span class="c1">#非贪婪模式进行匹配</span>
<span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.+&#39;</span><span class="p">,</span> <span class="n">mystr</span><span class="p">)</span> <span class="c1">#贪婪模式进行匹配</span>
<span class="p">[</span><span class="s1">&#39;a*b*c*d*e*f*g&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.*&#39;</span><span class="p">,</span> <span class="n">mystr</span><span class="p">)</span> <span class="c1">#贪婪模式进行匹配</span>
<span class="p">[</span><span class="s1">&#39;a*b*c*d*e*f*g&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.*?&#39;</span><span class="p">,</span> <span class="n">mystr</span><span class="p">)</span> <span class="c1">#非贪婪模式进行匹配</span>
<span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="c1">#结果不同在于对+号和*号特殊字符的解释</span>
</pre></div>


<h2>re模块函数：</h2>
<blockquote>
<p><strong>re.compile(pattern)</strong>
编译正则表达式
一般的，特殊字符再进行正则匹配的时候，如果你不预先编译正则表达式，解释器也会在你传入参数的时候进行编译
一些常用正则表达式，我们可以提前使用该函数进行预先编译，提高程序的效率</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
</pre></div>


<hr>
<blockquote>
<p><strong>re.match(pattern,string)</strong>
尝试使用正则模式<strong>pattern</strong>在字符串中的开头进行严格匹配，如果开头匹配失败则匹配失败
<strong>匹配成功</strong>：返回一个匹配对象，匹配到的值可通过<strong>group</strong>函数获取
<strong>匹配失败</strong>：返回<strong>None</strong></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="k">match</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span><span class="s1">&#39;abcac&#39;</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">_sre</span><span class="p">.</span><span class="n">SRE_Match</span> <span class="k">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="o">&gt;</span> <span class="o">#</span><span class="err">返回表示选择的区间以及匹配到的结果</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">res</span><span class="p">.</span><span class="k">group</span><span class="p">()</span>
<span class="s1">&#39;abc&#39;</span>
</pre></div>


<hr>
<blockquote>
<p><strong>re.findall(pattern,string)</strong>
返回字符串中正则模式的所有非重复出现</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;\*&#39;</span><span class="p">,</span><span class="s1">&#39;a*b*c*&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>
</pre></div>


<blockquote>
<p><strong>注意</strong>：由于匹配的表达式中，我希望匹配的只是单纯的<strong>*</strong>号，并不具有特殊意义，所以要加一个斜杠防止转义</p>
</blockquote>
<hr>
<blockquote>
<p><strong>re.search(pattern,string)</strong>
返回字符串中正则模式的第一次出现，没有匹配结果则返回<strong>None</strong>
结果可以通过返回值的group函数获取</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="k">search</span><span class="p">(</span><span class="s1">&#39;\*&#39;</span><span class="p">,</span><span class="s1">&#39;a*b*c*&#39;</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">_sre</span><span class="p">.</span><span class="n">SRE_Match</span> <span class="k">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">res</span><span class="p">.</span><span class="k">group</span><span class="p">()</span>
<span class="s1">&#39;*&#39;</span>
</pre></div>


<hr>
<blockquote>
<p><strong>re.sub(str1,str2,str3)</strong></p>
<p><strong>re.subn(str1,str2,str3)</strong>
<strong>str1</strong>：要替换的字符串
<strong>str2</strong>：替换成什么
<strong>str3</strong>：在哪个字符串里进行替换</p>
</blockquote>
<hr>
<blockquote>
<p>这两个函数都可以实现<strong>搜索</strong>和<strong>替换</strong>功能，均返回一个替换之后的新字符串</p>
<p><strong>subn</strong>函数会以元组形式包含一个表示替换的总数</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">var</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\*&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;a*b*c*&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">var</span>
<span class="s1">&#39;a_b_c_&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">var</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;\*&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;a*b*c*&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">var</span>
<span class="p">(</span><span class="s1">&#39;a_b_c_&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>

			<a href="http://localhost:8000/" class="twitter-share-button" data-via="" data-lang="en" data-size="large" data-related="">返回</a>
			<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
		</div>
<div class="meta wrapper">
	<time datetime="2019-08-08T10:20:00+02:00" pubdate>周四 08 八月 2019</time>
	<ul class="tag clearfix">
		<li><a href="/category/ji-zhu.html">技术</a></li>
		<li><a href="/tag/pelican.html">pelican</a></li>
		<li><a href="/tag/publishing.html">publishing</a></li>
	</ul>
</div>	</article>	
</div>
	
		
<footer class="clearfix">
	<div class="wrapper pages">
		<ul class="nav">
			<li><a href="/resume.html">个人简历</a></li>
		</ul>
	</div>
	
	<div class="copy wrapper">
		<ul class="social">
			<li><a href="#">You can add links in your config file</a></li>
			<li><a href="#">Another social link</a></li>
		</ul>
	
		<p role="contentinfo">		© 潇潇
<br>
			<a href="http://luckyxiaoxiao.cn/">luckyxiaoxiao.cn</a></p>
	</div>
</footer>
</body>
</html>